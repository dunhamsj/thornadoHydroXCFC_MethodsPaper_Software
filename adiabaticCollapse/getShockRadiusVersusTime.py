#!/usr/bin/env python3

from datetime import datetime

import os
import yt
import numpy as np
import multiprocessing as mp

import globalVariables as gv

from myUtilitiesModule import getPlotfileNumberArray, getMesh_1d, getFieldData, readDensityDecadesFile

plotfileDirectoryRoot \
  = gv.dataDirectory + 'adiabaticCollapse/'
dataDirectory \
  = plotfileDirectoryRoot + 'processedData/'

nProcs = mp.cpu_count()
print( '\n  nProcs = {:d}'.format( nProcs ) )

j = 2

plotfileNameRoot = 'AdiabaticCollapse_XCFC.plt'

def findShockRadiusVersusTime \
      ( suffix, rSh, verbose = True ):

    if ( verbose ) :
        print( '\n  Running getShockRadiusVersusTime for {:}' \
               .format( 'AdiabaticCollapse_XCFC{:}'.format( suffix ) ) )
        print(   '  ------------------------------------' )

    plotfileDirectory \
      = plotfileDirectoryRoot \
          + 'AdiabaticCollapse_XCFC{:}/'.format( suffix )

    plotfileNumberArray \
      = getPlotfileNumberArray \
          ( plotfileDirectory,\
            plotfileNameRoot )

    densityDecadesFileName \
      = dataDirectory \
          + 'DensityDecades{:}.dat'.format( suffix )

    indb, tb, rhob, indd, pfnd = readDensityDecadesFile( densityDecadesFileName )
    plotfileNumberArray = plotfileNumberArray[indb:]

    nSS = plotfileNumberArray.shape[0]
    SS  = np.linspace( 0, plotfileNumberArray.shape[0]-1, nSS, dtype = np.int64 )

    SSw = np.array_split( SS, nProcs )

    def worker( SSw, procnum, return_dict ):

        nSSl = SSw.shape[0]

        ss  = []
        t   = []
        Rsh = []

        for iSS in range( nSSl ):

            if ( verbose ) :
                print( '\r  {:d}/{:d}'.format( iSS, nSSl ), end = '\r' )

            plotfileName \
              = plotfileDirectory \
                  + plotfileNameRoot \
                  + str( plotfileNumberArray[SSw[iSS]] ).zfill( 8 )

            ds = yt.load( '{:}'.format( plotfileName ) )
            Time = ds.current_time.to_ndarray()

            if Time < tb: continue

            X1_C, X2_C, X3_C, dX1, dX2, dX3, xL, xH \
              = getMesh_1d( plotfileName, 'spherical' )

            Data \
             = getFieldData \
                 ( plotfileName, 'PF_V1', X1_C, X2_C, X3_C )

            sS            = 0
            shockTime     = 0.0
            gradient      = 0.0
            shockGradient = 0.0
            xS            = 0.0
            for i in range( j, X1_C.shape[0]-j ):

                if X1_C[i] < 5.0e1 or X1_C[i] > 7.9e3: continue

                gradient \
                  = np.abs( ( Data[i+j] - Data[i] ) \
                             / ( X1_C[i+j] - X1_C[i] ) )

                if( gradient > shockGradient ):
                    shockGradient = gradient
                    shockTime     = Time
                    xS            = X1_C[i]
                    sS            = i

            ss .append( indb + SSw[iSS]  )
            t  .append( shockTime )
            Rsh.append( xS        )

        return_dict[procnum] = [ ss, t, Rsh ]

        return

    # Parallel stuff from
    # https://stackoverflow.com/questions/10415028/
    # how-can-i-get-the-return-value-of-a-function-passed-to
    # -multiprocessing-process
    manager = mp.Manager()
    return_dict = manager.dict()
    jobs = []
    for i in range( nProcs ):
        p = mp.Process( target = worker, args = ( SSw[i], i, return_dict ) )
        jobs.append(p)
        p.start()

    for proc in jobs:
        proc.join()

    ss  = []
    t   = []
    Rsh = []

    for i in range( nProcs ):
        dtmp = return_dict[i]
        ss .append( dtmp[0] )
        t  .append( dtmp[1] )
        Rsh.append( dtmp[2] )

    ss  = np.array( np.concatenate( ss  ), dtype = np.int64   )
    t   = np.array( np.concatenate( t   ), dtype = np.float64 )
    Rsh = np.array( np.concatenate( Rsh ), dtype = np.float64 )

    ssarg = np.argsort( ss )

    ss  = ss [ssarg]
    t   = t  [ssarg]
    Rsh = Rsh[ssarg]

    arg = np.argmax( Rsh )
    ss  = ss [0:arg+1]
    t   = t  [0:arg+1]
    Rsh = Rsh[0:arg+1]

    filename = dataDirectory + 'ShockRadiusVsTime{:}.dat'.format( suffix )
    header = 'Filename: {:}\nGenerated by {:}\non {:}\nt-tb [ms], Rsh [km]' \
             .format( filename, __file__, datetime.today() )
    np.savetxt( filename, \
                np.vstack( ( t-tb, Rsh ) ), header = header )
    os.system( 'chmod 444 {:}'.format( filename ) )
    print( '  Saved {:}'.format( filename ) )

    iRsh = [ np.where( Rsh >= x )[0][0] for x in rSh ]
    N = len( iRsh )

    filename = dataDirectory + 'ShockRadiusSnapshots{:}.dat'.format( suffix )
    with open( filename, 'w' ) as f:

        f.write( '# Filename: {:}\n'.format( filename ) )

        f.write( '# Generated by {:}\n# on {:}\n' \
             .format( __file__, datetime.today() ) )

        f.write( 'snapshots = [ ' )
        for i in range( N-1 ):
            f.write( '{:d} '.format( np.int64( ss[iRsh[i]] ) ) )
        f.write( '{:d} ]\n' \
                 .format( np.int64( ss[iRsh[N-1]] ) ) )

        f.write( 'tmtb = [ ' )
        for i in range( N-1 ):
            f.write( '{:3e} '.format( np.float64( t[iRsh[i]]-tb ) ) )
        f.write( '{:3e} ] # ms\n' \
                 .format( np.float64( t[iRsh[N-1]]-tb ) ) )

        f.write( 'Rsh = [ ' )
        for i in range( N-1 ):
            f.write( '{:.3e} '.format( np.float64( Rsh[iRsh[i]] ) ) )
        f.write( '{:3e} ] # km' \
                 .format( np.float64( Rsh[iRsh[N-1]] ) ) )

    os.system( 'chmod 444 {:}'.format( filename ) )
    print( '  Saved {:}'.format( filename ) )

if __name__ == '__main__':

    verbose = True

    rSh = [ 1.0e2, 5.0e2, 1.0e3, 2.0e3, 4.0e3, 7.5e3 ]

    findShockRadiusVersusTime( '_AMR_dr0.25km', rSh, verbose = verbose )
    findShockRadiusVersusTime( '_AMR_dr0.50km', rSh, verbose = verbose )
    findShockRadiusVersusTime( '_AMR_dr1.00km', rSh, verbose = verbose )
    findShockRadiusVersusTime( '_Uni_dr0.50km', rSh, verbose = verbose )
    findShockRadiusVersusTime( '_Uni_dr1.00km', rSh, verbose = verbose )

    rSh = [ 1.0e2, 5.0e2, 1.0e3, 2.0e3 ]

    findShockRadiusVersusTime( '_AMR_dr0.25km_nLevels04', rSh, verbose = verbose )
    findShockRadiusVersusTime( '_AMR_dr0.25km_HLLC'     , rSh, verbose = verbose )

    os.system( 'rm -rf __pycache__' )
